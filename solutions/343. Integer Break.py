class Solution:
    def integerBreak(self, n: int) -> int:
        # 这道题目 我学习到了很妙 的一种 动态规划 递推公式 的推导
        dp = [0]*(n+1)     # 真的需要 构建这么大的数组来 存储值吗？ 我们可以 只维护一部分的数组空间吗？
                           # dp[0] 和 dp[1] 初始化为任意值 都可以，因为根本用不到，也不存在任何的实际意义
        dp[2] = 1
        #　将　数值为i 的正整数拆分为j *（i-j）或者是j*dp[i-j]
        for i in range(3,n+1):
            for j in range(1,i//2+1):  # 因为分离出来的j 不能超过需要被 拆分的正整数的一半，否则 做不到 最后分拆出来的元素 数值相近，只有分离出来的 元素数值相近，它们相乘起来的乘积 才有可能是 最大的。数学证明 不了解，但是根据 直观感受，想象 的出来。
                dp[i] = max(dp[i], j*(i-j),j*dp[i-j])     #　因为在嵌套　子循环里面，所以　每一次ｊ取值算出来的dp[i] 都不一定是最大值，需要比较到 dp[i] 的最大值。
        return dp[n]

        # 贪心的算法 需要用到数学证明，我就不想写了，以为我的确不想看数学证明了。
        